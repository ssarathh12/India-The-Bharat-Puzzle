<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>India Geo-Puzzle Map</title>

<script src="https://cdn.tailwindcss.com"></script>
<style>
/* Ensure Inter font is available or fall back to sans-serif */
@import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap');

html, body { height: 100%; margin: 0; padding: 0; font-family: 'Inter', sans-serif; overflow: hidden; }
#map { height: 100%; width: 100%; border-radius: 0.75rem; }
.leaflet-grab { cursor: grab; }
.leaflet-dragging .leaflet-grab { cursor: grabbing; }
</style>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
</head>
<body class="bg-gray-100 p-4 sm:p-6 flex flex-col h-screen">

<header class="mb-4 p-3 bg-white shadow-xl rounded-xl border-b-4 border-indigo-500 flex flex-col sm:flex-row justify-between items-start sm:items-center">
<div>
<h1 class="text-3xl font-extrabold text-indigo-700">India Geo-Puzzle</h1>
<p class="text-lg text-gray-700 font-semibold mt-1">Score: <span id="score" class="text-green-600">0 / 36</span></p>
</div>
<div class="flex items-center mt-2 sm:mt-0">
<p class="text-sm text-gray-600 mr-4" id="status-message">Initializing game data...</p>
<button id="shuffle-btn" class="px-4 py-2 bg-indigo-600 text-white rounded-lg shadow hover:bg-indigo-700 transition">Shuffle Pieces</button>
</div>
</header>

<div id="map" class="flex-grow shadow-2xl"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
const STATE_FILENAMES = ['ANDAMAN_and_NICOBAR.geojson', 'ANDHRA_PRADESH.geojson', 
'ARUNACHAL_PRADESH.geojson', 'ASSAM.geojson', 'BIHAR.geojson', 'CHANDIGARH.geojson', 
'CHHATTISGARH.geojson', 'DADRA_and_NAGAR_HAVELI_and_DAMAN_and_DIU.geojson', 'DELHI.geojson', 
'GOA.geojson', 'GUJARAT.geojson', 'HARYANA.geojson', 'HIMACHAL_PRADESH.geojson', 
'JAMMU_AND_KASHMIR.geojson', 'JHARKHAND.geojson', 'KARNATAKA.geojson', 'KERALA.geojson', 
'LADAKH.geojson', 'LAKSHADWEEP.geojson', 'MADHYA_PRADESH.geojson', 'MAHARASHTRA.geojson', 
'MANIPUR.geojson', 'MEGHALAYA.geojson', 'MIZORAM.geojson', 'NAGALAND.geojson', 'ODISHA.geojson', 
'PUDUCHERRY.geojson', 'PUNJAB.geojson', 'RAJASTHAN.geojson', 'SIKKIM.geojson', 'TAMIL_NADU.geojson', 
'TELANGANA.geojson', 'TRIPURA.geojson', 'UTTARAKHAND.geojson', 'UTTAR_PRADESH.geojson', 
'WEST_BENGAL.geojson'];

const TOTAL_PIECES = STATE_FILENAMES.length;
const SNAP_TOLERANCE_PIXELS = 20;
let gameState = { pieces: [], draggedPiece: null, score: 0 };

// --- Initialize map with Carto Voyager basemap ---
const map = L.map('map').setView([22.0, 78.0], 3);
L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; <a href="https://www.carto.com/">CARTO</a> &copy; OpenStreetMap contributors',
    subdomains: 'abcd',
    maxZoom: 19
}).addTo(map);

// --- Styles ---
// Style for pieces that have not been snapped
const geoJsonStyle = { color: "#ef4444", weight: 2, opacity: 0.8, fillColor: "#ef4444", fillOpacity: 0.5, className: "leaflet-grab" }; // red
// Style for pieces that have been snapped
const snappedStyle = { color: "#10b981", weight: 3, opacity: 1.0, fillColor: "#10b981", fillOpacity: 0.8 }; // green

// --- Core Helper Functions ---

/**
 * Iterates through the coordinates of a GeoJSON layer and applies a differential offset.
 * Used for both dragging and snapping correction.
 * @param {L.GeoJSON} layer - The GeoJSON layer to move.
 * @param {number} latDiff - Latitude difference.
 * @param {number} lngDiff - Longitude difference.
 */
function moveLayer(layer, latDiff, lngDiff) {
    const latlngs = layer.getLatLngs();
    const newLatLngs = latlngs.map(ringOrPolygon => {
        const applyDiff = coords => {
            if (coords.lat !== undefined && coords.lng !== undefined) return L.latLng(coords.lat + latDiff, coords.lng + lngDiff);
            // Handles MultiPolygon/Polygon structure (array of rings/polygons)
            return coords.map(applyDiff);
        };
        return applyDiff(ringOrPolygon);
    });
    layer.setLatLngs(newLatLngs);
}

// --- Drag Handlers ---
function handleDragStart(e) {
    const piece = e.target.piece;
    if (piece.isSnapped) return; // Prevent dragging snapped pieces

    // Bring the currently dragged piece to the front (Fix for overlapping)
    piece.layer.bringToFront();

    L.DomEvent.stop(e.originalEvent);
    map.dragging.disable();
    L.DomUtil.addClass(map.getContainer(), 'leaflet-dragging');
    gameState.draggedPiece = piece;
    piece.dragStartLatLng = e.latlng;

    // Enhance drag appearance
    piece.layer.setStyle({ opacity: 0.9, fillOpacity: 0.6, weight: 4 });

    map.on('mousemove', handleDrag);
    map.on('mouseup', handleDragEnd);
    // Removed status message update during drag start
}

function handleDrag(e) {
    const piece = gameState.draggedPiece;
    if (!piece || !piece.dragStartLatLng) return;
    const latDiff = e.latlng.lat - piece.dragStartLatLng.lat;
    const lngDiff = e.latlng.lng - piece.dragStartLatLng.lng;
    moveLayer(piece.layer, latDiff, lngDiff);
    piece.dragStartLatLng = e.latlng;
}

function handleDragEnd() {
    const piece = gameState.draggedPiece;
    if (!piece) return;
    map.dragging.enable();
    L.DomUtil.removeClass(map.getContainer(), 'leaflet-dragging');
    map.off('mousemove', handleDrag);
    map.off('mouseup', handleDragEnd);

    checkSnap(piece);

    // Revert style if not snapped
    if (!piece.isSnapped) {
        piece.layer.setStyle(geoJsonStyle);
    }
    // Removed status message update for failed drag end
    gameState.draggedPiece = null;
}

function checkSnap(piece) {
    const currentCenter = piece.layer.getBounds().getCenter();
    const currentPixel = map.latLngToContainerPoint(currentCenter);
    const targetPixel = map.latLngToContainerPoint(piece.targetCenter);
    const pixelDistance = currentPixel.distanceTo(targetPixel);

    if (pixelDistance <= SNAP_TOLERANCE_PIXELS) {
        // Correction moves the piece to its original target center
        const latCorrection = piece.targetCenter.lat - currentCenter.lat;
        const lngCorrection = piece.targetCenter.lng - currentCenter.lng;
        moveLayer(piece.layer, latCorrection, lngCorrection);

        piece.isSnapped = true;
        piece.layer.setStyle(snappedStyle);

        // Crucial: Remove drag cursor and event handler for snapped pieces (Fix for overlapping)
        if (piece.layer._path) piece.layer._path.style.cursor = 'default';
        piece.layer.off('mousedown', handleDragStart);

        // Bring all other non-snapped pieces to front to prevent them from being stuck (Fix for overlapping)
        gameState.pieces.forEach(p => {
            if (!p.isSnapped) {
                p.layer.bringToFront();
            }
        });

        gameState.score++;
        document.getElementById('score').textContent = `${gameState.score} / ${TOTAL_PIECES}`;
        
        // RETAINED: Status message update for successful snap
        document.getElementById('status-message').textContent = `SUCCESS! ${piece.name} snapped into place!`;
        document.getElementById('status-message').className = 'text-green-600 font-bold';
        if (gameState.score === TOTAL_PIECES) {
            document.getElementById('status-message').textContent = "PUZZLE COMPLETE! All pieces are in place!";
        }
    } else {
        // Removed status message update for failed snap
    }
}

/**
 * Places the layer randomly outside the main India boundary (West of 68 or East of 98).
 * @param {L.GeoJSON} layer - The GeoJSON layer to place.
 */
function placeRandomlyOutsideIndia(layer) {
    const bounds = layer.getBounds();
    const currentCenter = bounds.getCenter();
    let newCenterLat, newCenterLng;

    // Use a wider range of latitudes for better dispersal
    const LAT_MIN = 8;
    const LAT_MAX = 37;

    if (Math.random() < 0.5) {
        // Place West of 68° E (Pakistan/Arabian Sea)
        newCenterLng = 60 + Math.random() * (67 - 60); // 60 to 67
    } else {
        // Place East of 98° E (SE Asia)
        newCenterLng = 99 + Math.random() * (108 - 99); // 99 to 108
    }

    // Random latitude within a reasonable range
    newCenterLat = LAT_MIN + Math.random() * (LAT_MAX - LAT_MIN);

    const latCorrection = newCenterLat - currentCenter.lat;
    const lngCorrection = newCenterLng - currentCenter.lng;
    moveLayer(layer, latCorrection, lngCorrection);
}


// --- Main Load Function ---
async function loadAndInitializePuzzle() {
    const statusMessage = document.getElementById('status-message');
    statusMessage.textContent = `Loading ${TOTAL_PIECES} GeoJSON files...`;

    const fetchPromises = STATE_FILENAMES.map(fileName =>
        fetch(fileName)
            .then(response => {
                // Reminder: This must be run on a local web server (e.g., Live Server) to load GeoJSON files.
                if (!response.ok) throw new Error(`Failed to load ${fileName}`);
                return response.json();
            })
            .then(data => ({ name: fileName.replace(".geojson","").replace(/_/g,' '), data }))
            .catch(err => { console.error("Error fetching file:", fileName, err); return null; })
    );

    const allGeoJsonData = (await Promise.all(fetchPromises)).filter(item => item !== null);
    if (allGeoJsonData.length === 0) {
        statusMessage.textContent = "FATAL ERROR: Could not load any GeoJSON data. Please ensure you are running this on a local web server.";
        statusMessage.className = 'text-red-600 font-bold';
        return;
    }

    document.getElementById('score').textContent = `0 / ${allGeoJsonData.length}`;

    allGeoJsonData.forEach(item => {
        const stateName = item.name;
        const originalGeoJsonData = item.data;

        // 1. Determine True Target Center (from original data)
        const dummyLayer = L.geoJSON(originalGeoJsonData);
        const targetCenter = dummyLayer.getBounds().getCenter();
        dummyLayer.remove(); // Clean up the dummy layer

        // 2. Create the Leaflet Layer using ORIGINAL GeoJSON data (Fix for gaps)
        const layer = L.geoJSON(originalGeoJsonData, {
            style: geoJsonStyle,
            onEachFeature: (feature, layer) => {
                const piece = {
                    name: stateName,
                    layer,
                    targetCenter, // Store the ORIGINAL center for snapping
                    isSnapped: false,
                    dragStartLatLng: null
                };
                layer.piece = piece;
                layer.on('mousedown', handleDragStart);

                // 3. Place piece outside India boundary
                placeRandomlyOutsideIndia(layer);

                gameState.pieces.push(piece);
            }
        }).addTo(map);
    });

    statusMessage.textContent = `Game loaded with ${allGeoJsonData.length} regions. Drag the pieces back to India!`;
    statusMessage.className = 'text-indigo-700 font-medium';
}

// --- Shuffle button ---
document.getElementById('shuffle-btn').addEventListener('click', () => {
    gameState.pieces.forEach(piece => {
        if (!piece.isSnapped) {
            placeRandomlyOutsideIndia(piece.layer);
            piece.layer.setStyle(geoJsonStyle);
            // Re-enable drag handlers and cursor for pieces that were previously moved but not snapped
            piece.layer.on('mousedown', handleDragStart);
            if (piece.layer._path) piece.layer._path.style.cursor = 'grab';
            piece.layer.bringToFront(); // Bring all non-snapped pieces to front
        }
    });
    document.getElementById('status-message').textContent = "Pieces shuffled to non-target regions!";
    document.getElementById('status-message').className = 'text-indigo-700 font-medium';
});

loadAndInitializePuzzle();
</script>
</body>

</html>
